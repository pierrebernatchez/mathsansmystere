#!/usr/bin/python3
# -*- coding: utf-8 -*-
u"""
Compiles information derived from the contents of a source directory
into reStructuredText that will be further compiled downstream by
pelican.py ultimately to produce static web pages.
"""
from __future__ import print_function
import sys
import os
import argparse
import subprocess
import json
import tempfile
import getpass
import pwd
import grp
import glob
import stat
from mutagen.easyid3 import EasyID3

FULLPROGNAME=os.path.abspath(os.path.expanduser(__file__))
MYPROGNAME=os.path.basename(FULLPROGNAME)
MYPROGDIR=os.path.dirname(FULLPROGNAME)
MYCURRDIR=os.getcwd()

MYOUTPAGESDIR=os.path.join(MYCURRDIR, 'content', 'pages')
# use this to remap album names
# CAVEAT should be getting this from a config file in the content.
# We are using it to replace album name pulled from mp3 to what we want in page.
ALBUM_SUBS = { "lo mejor de la champeta urbana y africana" : "Champeta Africana",
               "lo mejor de la champeta urbana" : "Champeta Urbana"}


def previous_page_list(prefix, target_directory):
    """Generate a list of existing presumably previously compiled pages"""
    previous_single = os.path.join(target_directory, prefix + '.rst')
    previous_pattern = os.path.join(target_directory, prefix + '_[0-9]*.rst')
    prev_list = glob.glob(previous_single)
    prev_list.extend(glob.glob(previous_pattern))
    return prev_list



def inspect_file(filepath):
    """Figure out what audio file tags you can for the given file"""
    easyid3 = EasyID3(filepath)
    results = {
        "filename": os.path.basename(filepath),
        "directory": os.path.dirname(filepath),
        "title":easyid3["title"][0],
        "artist": easyid3["artist"][0],
        "album": easyid3["album"][0],
        "date": easyid3["date"][0],
        "tracknumber": easyid3["tracknumber"][0]
#        "comment": easyid3["comment"][0]
        }
    return results


def generate_track_database(filepathlist):
    """build a database of albums from the tags in the audio files"""
    albumtracks={}
    for afilepath in filepathlist:
        trackentry=inspect_file(afilepath)
        album = trackentry["album"]
        tracknumber = trackentry["tracknumber"]
        try:
            tracklist = albumtracks[album]
        except KeyError:
            tracklist = []
        tracklist.append((tracknumber, trackentry))
        albumtracks[album]=tracklist
    return albumtracks

def generate_source_list(fullpattern):
    """Make a list of the file names in sourcedir"""
    def is_a_file(path):
        """Return true if the path is a regular file"""
        statrec = os.stat(path, follow_symlinks=True)
        if stat.S_ISREG(statrec.st_mode):
            return True
        else:
            return False
    source_list=glob.glob(fullpattern)
    short_list = [afile for afile in source_list if is_a_file(afile)]
    return short_list



def emit_rst(tlist_basename, link_subdirectory, outstream):
    """Emit to outstream a list of rst links to files in link_subdirectory"""
    link_format = '* `{0} <{1}/{2}/{0}>`_'
    for aball in tlist_basename:
        print(link_format.format(aball,'{filename}',link_subdirectory),file=outstream)


# Page header is rst format content that precedes list of links to mp3 files.
audio_page_header="""{album}
{1}

:date: {date}
:tags: audio, track
:slug: {2}
:author: Generated by {0}
:summary: Music Album or Compilation

Compilation Name: {album}

title - artist - tracknumber

"""
def emit_simple_links(tlist_basename, link_subdirectory, outstream):
    """Emit a list of links in rst format to be included by a pelican.py content page"""
    link_format = '* `{0} <{1}/{2}/{0}>`_'
    for atarget in tlist_basename:
        print(link_format.format(atarget,'{static}',link_subdirectory),file=outstream)

def emit_audio_links(stracks, link_subdirectory, outstream, header_line=None):
    """Emit a list of audio content links in rst format"""
    if header_line is not None:
        print(header_line, file=outstream)
    track_format="* `{title} - {artist} - {tracknumber} <{0}/{1}/{filename}>`_"
    for atrack in stracks:
        print(track_format.format('{static}', link_subdirectory, **atrack), file=outstream)

def emit_audio_page(stracks, slug, link_subdirectory, outstream, album_subs=ALBUM_SUBS):
    """Emit an audio compilation page in rst format as a pelican content page"""
    def map_album( akey ):
        if akey in album_subs:
            print(album_subs[akey],file=sys.stderr)
            return album_subs[akey]
        else:
            print(akey,file=sys.stderr)
            return akey
        
    first_track = dict(stracks[0].items()) # to make it be a copy
    first_track['album'] = map_album(first_track['album'])
    uline = "#" * len(first_track['album'])
    print(audio_page_header.format(MYPROGNAME, 
                                   uline, 
                                   slug, 
                                   **first_track), file=outstream)
    emit_audio_links(stracks, link_subdirectory, outstream)

if __name__ == '__main__':
    PARSER = argparse.ArgumentParser(prog=MYPROGNAME, description=__doc__)
    dflt_source_directory="compilations"
    PARSER.add_argument('-p', '--pattern', dest='pattern',
                        help="file name pattern of input files (default *)")
    PARSER.add_argument('-s', '--source-directory', dest='source_directory', default=dflt_source_directory,
                        help="Subdirectory where file pattern will be expanded (default '{}')".format(dflt_source_directory))
    PARSER.add_argument('-o', '--output-name', dest='output_name', default="album",
                        help="Constant prefix of output file name pattern (default '{}')".format("album"))
    PARSER.add_argument('-d', '--dryrun', dest='dryrun', action='store_true', 
                                help="Emit to stdout rather than output file")
    command_group = PARSER.add_argument_group(title="Type of output to produce")
    xcommand_group =  command_group.add_mutually_exclusive_group(required=True)
    xcommand_group.add_argument('-e', '--examine-audio', dest='examine_audio', action='store_true', 
                                help="Examine the input audio files and dump the information to stdout in json format")
    xcommand_group.add_argument('-a', '--audio-pages', dest='audio_pages', action='store_true', 
                                help="Emit audio pages, a page for each album, possibly overwriting previously emitted page")
    xcommand_group.add_argument('-r', '--remove-pages', dest='remove_pages', action='store_true', 
                                help="Remove all pages matching the generated name pattern")
    xcommand_group.add_argument('-i', '--include-list', dest='include_list', action='store_true', 
                                help="Emit a simple list of links as an include file")
    ARGS = PARSER.parse_args()
    if ARGS.pattern is None:
        pattern="*"
    else:
        pattern=ARGS.pattern
    rootdir=os.path.join(MYCURRDIR,'content')
    fullpattern=os.path.join(rootdir, ARGS.source_directory, pattern)
    print("{}: source file pattern: {}".format(MYPROGNAME, fullpattern), file=sys.stderr)
    tlist = generate_source_list(fullpattern)

    if ARGS.examine_audio:
        print("{}: source file mode: inspect_audio".format(MYPROGNAME), file=sys.stderr)
        album_db = generate_track_database(tlist)
        album_tracks = album_db.items()
        json.dump(album_tracks, sys.stdout, indent=4)
    elif ARGS.audio_pages:
        print("{}: source file mode: audio_pages".format(MYPROGNAME), file=sys.stderr)
        album_db = generate_track_database(tlist)
        album_tracks = album_db.items()
        if len(album_tracks) > 1:
            slug_format = ARGS.output_name + "_{}"
        else:
            slug_format = ARGS.output_name
        
        slug_pattern = slug_format.format('{number}')
        print("{}: output file pattern: {}.rst".format(MYPROGNAME,
                                                       os.path.join(MYCURRDIR,
                                                                    'content',
                                                                    'audio',
                                                                    slug_pattern)), 
                                                       file=sys.stderr)
        target_directory = os.path.join(MYCURRDIR,'content','audio')
        previous_list = previous_page_list(ARGS.output_name, target_directory)
        count = 0
        new_list=[]
        for album, tracks in album_tracks:
            count = count + 1
            slug = slug_format.format(count)
            target_path = os.path.join(target_directory, slug)
            new_list.append(target_path + ".rst")
            sorted_tracs = [ atrack for sortkey, atrack in sorted(tracks)]
            if ARGS.dryrun:
                print("{}: displaying {}".format(MYPROGNAME, slug),file=sys.stderr)
                emit_audio_page(sorted_tracs, slug, ARGS.source_directory, sys.stdout)
            else: 
                with open(target_path + ".rst" , "w") as outpage:
                    print("{}: emitting {}".format(MYPROGNAME, slug),file=sys.stderr)
                    emit_audio_page(sorted_tracs, slug, ARGS.source_directory, outpage)
        # we do this afterwards to avoid all removals
        # when the previous loop craps out
        if not ARGS.dryrun:
            for afile in previous_list:
                if not afile in new_list:
                    print("{}: removing previous: {}".format(MYPROGNAME, afile))
                    os.remove(afile)
        
    elif ARGS.include_list:
        print("{}: source file mode: include_list".format(MYPROGNAME), file=sys.stderr)
        outputfilename=os.path.join(MYCURRDIR, ARGS.output_name + '.rst')
        print("{}: output file name: {}".format(MYPROGNAME, outputfilename),
                                                       file=sys.stderr)
        tlist_basenames =[ os.path.basename(afile) for afile in tlist]
        if ARGS.dryrun:
            emit_simple_links(tlist_basenames, ARGS.source_directory, sys.stdout)
        else:
            with open(outputfilename, "w") as out_file:
                emit_simple_links(tlist_basenames, ARGS.source_directory, out_file)
    elif ARGS.remove_pages:
        target_directory = os.path.join(MYCURRDIR,'content','pages')
        includefilename=os.path.join(MYCURRDIR, ARGS.output_name + '.rst')
        previous_list = previous_page_list(ARGS.output_name, target_directory)
        if os.path.exists(includefilename):
            previous_list.append(includefilename)
        for afile in previous_list:
            if ARGS.dryrun:
                print("{}: removal inhibited by 'dryrun':{}".format(MYPROGNAME, afile), 
                      file=sys.stderr)
            else:
                print("{}: remove previous: {}".format(MYPROGNAME, afile), file=sys.stderr)
                os.remove(afile)
    elif ARGS.clear_include_pages:
        target_directory = os.path.join(MYCURRDIR,'content','pages')
        previous_list = previous_page_list(ARGS.output_name, target_directory)
        for afile in previous_list:
            if ARGS.dryrun:
                print("{}: removal inhibited by 'dryrun':{}".format(MYPROGNAME, afile), 
                      file=sys.stderr)
            else:
                print("{}: remove previous: {}".format(MYPROGNAME, afile), file=sys.stderr)
                os.remove(afile)
    else:
        raise ValueError("software rot: reached unreachable statement")
        
    

            








        

  
   
